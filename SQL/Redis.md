# 数据类型

| 数据类型   | 编码         | 对象            |
| ------ | ---------- | ------------- |
| String | int        | 整数值实现         |
| String | embstr     | SDS实现 <= 39字节 |
| String | raw        | SDS实现 > 39字节  |
| List   | ziplist    | 压缩链表实现        |
| List   | linkedlist | 双端链表实现        |
| Set    | intset     | 整数集合实现        |
| Set    | hashtable  | 字典实现          |
| Hash   | ziplist    | 压缩列表实现        |
| Hash   | hashtable  | 字典实现          |
| Zset   | ziplist    | 压缩列表实现        |
| Zset   | skiplist   | 跳表和字典实现       |
|        |            |               |

## String字符串

可以是字符串、整数或浮点数   

 对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作

## List列表

一个链表，链表上的每个节点都包含一个字符串    

对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；

## Set集合

包含字符串的无序集合    

字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等

## Hash散列

包含键值对的无序散列表 

包含方法有添加、获取、删除单个元素

## Zset有序集合

和散列一样，用于存储键值对    

字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素

# 持久化

**RDB（RedisDB）和AOF（Append Only File）**

1. RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储

2. AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。

3. 只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化

4. 同时开启两种持久化方式
   
   1. 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
   
   2. RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。

5. 性能建议
   
   1. 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。
   
   2. 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。
   
   3. 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。

# 常见问题

### 缓存穿透

> 用户需要查询一个数据，但是redis中没有（比如说mysql中id=-1的数），直接去请求MySQL，当很多用户同时请求并且都么有命中！于是都去请求了持久层的数据库，那么这样会给持久层数据库带来非常大的压力。
> 
> Redis和MySQL中都没有，不停的直接请求MySQL

**解决方法**

1. 当查询不到数据时，也将对应的key放入缓存，不过值为null，避免后续可能的对数据库产生的巨大压力，当新增该key的数据时，覆盖

2. 使用布隆过滤器。布隆过滤器主要是解决大规模数据下不需要精确过滤的业务场景，如检查垃圾邮件地址，爬虫URL去重，解决缓存穿透问题等



### 缓存击穿

> 是指一个非常热点的key，在不停的扛着大并发，当这个key失效时，一瞬间大量的请求冲到持久层的数据库中，就像在一堵墙上某个点凿开了一个洞

**解决方法**

1. 定时任务主动刷新更新缓存



### 缓存雪崩

> 在某一个时间段，缓存的key大量集中同时过期了，所有的请求全部冲到持久层数据库上，导致持久层数据库挂掉
> 
> 范例：双十一零点抢购，这波商品比较集中的放在缓存，设置了失效时间为1个小时，那么到了零点，这批缓存全部失效了，而大量的请求过来时，全部冲过了缓存，冲到了持久层数据库

**解决方法** 

Redis高可用

搭建Redis集群，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）



限流降级

在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对
某个key只允许一个线程查询数据和写缓存，其他线程等待。



数据预热

数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀 。 

# Cluster模式

[redis集群 数据分片 哈希槽_redis集群hash槽](https://blog.csdn.net/hudeyong926/article/details/120950525)

        Redis Cluster是一种服务器Sharding技术，3.0版本开始正是提供。集群中，各Redis服务器相互连通，各自存储的数据也不一样。

        Redis集群没有使用一致性hash，而是引入了哈希槽hash slot的概念。所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，**每个key通过CRC16校验后对16384取模来决定放置哪个槽(Slot)**，每一个节点负责维护一部分槽以及槽所映射的键值数据。在Redis Cluster中，只有Master才拥有槽的所有权，如果是某个Master的slave，这个slave只负责槽的使用，但是没有所有权。

>         默认情况下，redis集群的读和写都是到master上去执行的，不支持slave节点读和写，跟Redis主从复制下读写分离不一样，因为redis集群的核心的理念，主要是使用slave做数据的热备，以及master故障时的主备切换，实现高可用的。
> 
>         Redis的读写分离，是为了横向任意扩展slave节点去支撑更大的读吞吐量。而redis集群架构下，本身master就是可以任意扩展的，如果想要支撑更大的读或写的吞吐量，都可以直接对master进行横向扩展。

        假设现在有3个节点，按照用户自己的规则手动分配的话，平均每个节点大约得到16384/3 = 5460个

        这种结构很容易添加或删除节点，并且无论是添加删除还是修改，都不会造成集群不可用的状态。**使用哈希槽的好处就在于可以方便的添加或移除节点**。

1. 当需要新增时，只需要把其他节点的某些哈希槽挪到新节点即可

2. 当需要移除时，只需要移除节点上的哈希槽到其他节点就好

## 特点

- 解耦数据和节点之间的关系，简化了节点扩容和收缩难度

- 节点自身维护槽的映射关系，不需要客户端或代理服务维护槽分区元数据

- 支持系欸但、槽和键之间的映射查询，用于数据路由，在线集群伸缩等场景

### 为什么RedisCluster会设计成16384个槽呢

        理论上crc16算法可以得到2^16个数值，其数值范围在0-65535之间，取模运算key的时候，应该是crc16(key)%65535

**1.如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。**
        如上所述，在消息头中，最占空间的是 myslots[CLUSTER_SLOTS/8]。 当槽位为65536时，这块的大小是: 65536÷8÷1024=8kb因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。

**2.redis的集群主节点数量基本不可能超过1000个。**
        如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。

**3.槽位越小，节点少的情况下，压缩率高**
        Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。16384÷8=2kb，怎么样，神奇不！综上所述，作者决定取16384个槽，不多不少，刚刚好！

## 通信: goosip协议

        Redis集群中，不同节点之间采用`gossip协议`进行通信，目的是为了维护节点之间的元数据信息。通过该协议达到最终数据的一致性。

### 过程

        Redis集群中节点的通信过程如下：

- 集群中每个节点都会单独开一个TCP通道，用于节点间彼此通信

- 每个节点在固定周期内通过待定的规则选择几个节点发送ping消息

- 接收到ping消息的节点用pong消息作为响应

# Sentinel（哨兵）模式

        哨兵是一个独立的进程，通过发送命令，等待Reids服务器响应，从而监控运行的多个Redis实例。所以它的主要目的，其实就是**在主从模式的基础上，用自动化服务替代其中的人为介入操作**。

**作用**

- 通过发送命令，让Redis返回监控其运行状态，包括主机和从机

- 当哨兵检测到主机宕机时，会自动将从机切换成主机，然后通过发布订阅模式通知其他的从机，修改配置文件，让它们切换主机

然而一个哨兵对Redis服务器的监控也可能会出现问题，所以可以使用多个哨兵进行监控，并且各个哨兵之间也会互相监控，这样就形成了**多哨兵模式**。

![](C:\Users\30935\AppData\Roaming\marktext\images\2023-05-24-14-26-34-image.png)

**故障切换的过程**

        假设Master宕机，哨兵1先检测这个结果，系统不会马上进行`failover`过程，仅仅是哨兵1认为Master不可用，这个现象称为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，进行`failover`操作。切换成功后就会通过发布订阅的模式，让各个哨兵把自己监控的Slave切换成Master，这个过程称为**客观下线**。对客户端而言，一切都是透明的

## 工作方式

- 每个哨兵进程以每秒钟一次的频率向集群中的Master、Slave以及其他的哨兵发送一个ping命令

- 如果一个实例距离最后一次有效回复ping命令的时间超过`down-after-milliseconds`的值，那么就会被哨兵标记为主观下线（SDOWN）

- 如果一个Master被标记为`SDOWN`，则正在监视该Master的哨兵要以每秒一次的频率确认Master主机的确进入了主观下线状态

- 当有足够数量的哨兵在指定的时间范围内确认Master主服务器进入了`SDOWN`，则Master会被标记为客观下线（ODOWN）

- 在一般情况下，每个哨兵会以10秒一次的频率向集群的所有Master，Slave发送`INFO`命令

- 当Master被哨兵标记为`ODOWN`后，哨兵向下线的master的所有Slave发送`INFO`命令的频率改为每秒一次

- 若没有足够数量的哨兵同意Master下线，则Master的`ODOWN`状态会被移除；若Master重写向哨兵发送PING命令返回有效回复，其`SDOWN`状态也会被移除

## 优点

- 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式也有

- 主从可以自动切换，系统更健壮，可用性更高

## 缺点

- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂

# 主从复制模式

        集群中的每个节点都有1~N个副本，其中一个为主机Master，其余的N-1个都为从机Slave。

        当主节点故障无法服务时，从节点会接替主机的功能。但是当主从都故障时，集群还是会停止运作的

## 原理

![](C:\Users\30935\AppData\Roaming\marktext\images\2023-05-23-22-15-57-image.png)

- 从数据库启动后，连接数据库，发送`SYNC`命令

- 主数据库接收到`SYNC`命令后，开始执行`BGSAVE`命令生成RDB文件，并使用缓冲区记录此后执行的所有命令

- 主数据库`BGSAVE`执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令

- 从数据库收到快照文件后，会丢弃所有旧数据，然后载入新的快照

- 当主服务器快照发送完成后，开始向从数据库发送缓冲区中的写命令

- 从数据库完成快照的载入后，开始接收并执行来自主数据库缓冲区的写命令

- 主数据库每执行一个写命令，就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令

- 出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库，增量复制

- 主从刚开始连接时，先进行全量同步；全量同步完成后再进行增量同步。Redis的策略是首先会尝试增量同步，如不成功回进行全量同步

## 优点

- 读写分离

- Slave同样可以接收其他Slaves的连接和同步请求，可以为Master分压

- Master是以非阻塞的方式为Slaves提供服务，所以在同步期间，客户端仍然可以查询或修改，Slave同理

## 缺点

- 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或人工介入

- 由于异步复制的原理，无法保证强一致性

- 如果多个Slave断开了，重启时最好错开，否则会同时多个SYNC请求，可能会导致Master IO剧增从而宕机

- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂
