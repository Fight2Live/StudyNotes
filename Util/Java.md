# 数据类型

## 内置数据类型

- byte

- short

- int

- long

- float

- double

- boolean

- char

## 引用数据类型

        引用类型指向一个对象，指向对象的变量是引用变量。

- 数组

- 对象

- String

## 常量

        用`final`来修饰，如：

```java
final double Pi = 3.1415927;

```

## 变量类型

### 静态变量

       定义在类中，方法之外的变量，并且使用`static`关键字修饰，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问，静态变量的值在程序运行期间只有一个副本。并且可以被访问修饰符修饰。

### 局部变量

        定义在方法、构造方法活语句块中的变量，作用域直线与当前方法、构造方法或语句块中。局部变量必须在使用前声明，并且不能被访问修饰符修饰

### 成员变量

        定义在类中、方法之外的变量，作用域为整个类，可以被类中的任何方法、狗崽方法和语句块访问。可悲访问修饰符修饰

### 参数变量

        方法定义时声明的变量，作为调用该方法时传递的值。



# 泛型

        是指未知的具体类型，可以写一个泛型方法来接收不同类型的参数。

- E - Element

- T - Type

- K - Key

- V - Value

- N - Number

- ? - 表示不确定的java类型



# 反射





# 多线程

## 生命周期

![](https://img-blog.csdnimg.cn/36a712dbdff642048611a26849294d1e.png)

- 就绪状态

        又叫做可运行状态，标识当前线程具有抢夺CPU时间片的权利。当一个线程抢夺到CPU时间片后就开始执行run方法，并标志着线程进入运行状态

- 运行状态

        run方法的执行标志着线程进入运行状态，当之前占有的CPU时间片用完之后，就会重新回到就绪状态继续抢夺CPU时间片，直到再次抢到，往复循环

- 阻塞状态

        当遇到阻塞事件，如键盘输入、sleep方法等，会进入阻塞状态，它会放弃之前占有的CPU时间片，再次回到就绪状态抢夺时间片

- 锁池

        在这里找共享对象的对象锁。线程进入锁池招共享对象的对象锁时，会释放之前占有的CPU时间片，也可能找到也有可能没找到，如果找到了就会进入就绪状态继续抢夺CPU时间片。进入锁池本身其实是一种阻塞状态。

## 实现方式

- 继承`Thread`类

- 实现`Runnable`接口

- 实现`Callable`接口

## 调度

线程的调度有两种模型：均分式调度和抢占式调度。

- 均分式调度模型：所有的线程轮流使用CPU的使用权，平均分配给每一个线程占用CPU的时间

- 抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么就会随机选择一个线程来执行，优先级高的占用CPU时间相对来说会高一点

> JVM使用的就是抢占式调度模型

## 线程池

        首先创建一些线程，他们的集合称之为线程池。线程池在系统启动时会创建大量空闲线程，程序将一个任务传递给线程池，线程池就会启动一条线程来执行这个任务，执行结束后线程销毁，而是再次返回到线程池中成为空闲状态，等待执行下一个任务。

        在多线程运行时，系统不断创建和销毁线程，成本非常高，会过度的小号系统资源，从而可能导致系统资源崩溃，使用线程池就是最好的选择。

### 工作机制

        在线程池的编程模式下，任务是分配给整个线程池的，而不是直接提交给某个线程。线程池拿到任务后，就会在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲线程。
