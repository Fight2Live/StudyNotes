# 介绍

- JVM是一种用于计算设备的规范，是一个虚构出来的及其，通过在时机的计算机上仿真模拟各种功能实现的。

- 包含一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域

- 屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码，就开源在多种平台上不加修改的运行

> （1）JRE(Java Runtime Environment)，也就是java平台。所有的java程序都要在JRE环境下才能运行。
> （2）JDK(Java Development Kit)，是开发者用来编译、调试程序用的开发包。JDK也是JAVA程序需要在JRE上运行。
> （3）JVM(Java Virtual Machine)，是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

        JVM是Java的核心和基础，在Java编译器和OS平台之间的虚拟处理器，可在上面执行字节码程序

# 生命周期

        JVM实例对应了一个独立运行的Java程序，它是进程级别的

- 启动，启动一个Java程序时，一个JVM实例就产生了

- 运行。main函数作为该程序初始线程的七点，任何其他线程均由该线程启动。

- 消亡。当程序中的所有非守护线程都种植，JVM才会退出；或者通过Runtime类或System.exit()来退出

    

        JVM执行引擎实例则对应了属于用户运行程序的线程，它是线程级别的

# 内存模型

主要由五部分组成

- 虚拟栈

- 本地方法栈

- 程序计数器

- 堆

- 方法区

![](https://img-blog.csdnimg.cn/img_convert/3c62f8d0b3ed1ece0988503b2d31057e.png)

## 虚拟栈、Java栈

        存放一个个栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括**局部变量表(Loval Variables)**、**操作数栈(Operand Stack)**、**指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)**、**方法返回地址(Return Address)** 和一些额外的附加信息。

        当线程执行一个方法时，就会随之创建一个对应的栈帧，并将简历的栈帧压栈。当方法执行完毕之后便会将栈帧出栈

## 本地方法栈

        它与Java栈的作用和原理非常相似，区别只不过是Java栈是为了执行Java方法服务的，而本地方法栈则是喂执行本地方法(Native Method)服务的

## 程序计数器

        由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。

        因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变。

        因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。

## 堆

        用来存储对象本身的，以及数组（数组的引用则是存放在Java栈中）。

        堆是被所有线程共享的，在JVM中只有一个堆。

## 方法区

        与堆一样，是被线程共享的区域。

        在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

        在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是**常量池**，用来存储编译期间生成的字面量和符号引用。

        还有一个非常重要的部分就是**运行时常量池**，它是每一个类或接口的常量池的**运行时表示形式**，在类和接口被加载到JVM后，对应的运行时常量池就会被创建出来，当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入，比如String的intern方法。

# 内存溢出情况

![](C:\Users\30935\AppData\Roaming\marktext\images\2023-06-06-17-40-49-image.png)

1. 如果虚拟机栈中，线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常

2. 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常

> 这两种情况存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，本质是一样的

3. 在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是`StackOverflowError`异常；而在多线程环境下，则会抛出`OutOfMemoryError`异常

4. 当堆中没有内存可分配时，并且堆也无法扩展时，将会抛出`OutOfMemoryError`异常

5. 当方法区无法满足内存分配需求时，将抛出`OutOfMemoryError`异常

# 垃圾回收

        垃圾回收是针对堆区的，在其中整体上华为两大部分：新生区和老年区，所以是采取分代收集的方法进行挥手处理

## 新生代

        所有新生成的对象都会首先落在新生代，而新生代的目标是尽可能快速的手机掉那些生命周期短的对象。

        新生代内存按照8：1：1的比例分为一个**eden区**和两个**survivor（0，1）区** 。大部分对象都在eden中生成，回收时会先将eden区中存活的对象复制到survivor0中，然后清空eden。

        当survivor0也满了之后，则将eden和survivor0中存活的对象复制到survivor1里，并对前两者清空，然后再将survivor1的对象移回survivor0，保持survivor1为空，如此往复。

        当survivor1不足以存放存活的所有对象时，就将存活对象直接放到老年代。若依老年代也满了就会触发一次`FULL GC` ，也就是新生代、老年代都进行回收。

        新生代发生的GC也叫做`Minor GC`，发生的频率较高，不一定等Eden满了才触发。

        

## 老年代

        在新生代中精灵了N次回收后仍然存活的对象，会被放到老年代中。因此可以认为老年代中存放的都是一些生命周期较长的对象。

        内存比新生代也大很多，当老年代内存满时会触发`Major GC` ，即`Full GC`，不过发生频率较低
