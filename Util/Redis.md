

# 持久化

**RDB和AOF**

1. RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储

2. AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。

3. 只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化

4. 同时开启两种持久化方式
   
   1. 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
   
   2. RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。

5. 性能建议
   
   1. 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。
   
   2. 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。
   
   3. 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。



# 常见问题

### 缓存穿透

> 用户需要查询一个数据，但是redis中没有（比如说mysql中id=-1的数），直接去请求MySQL，当很多用户同时请求并且都么有命中！于是都去请求了持久层的数据库，那么这样会给持久层数据库带来非常大的压力。
> 
> Redis和MySQL中都没有，不停的直接请求MySQL

### 缓存击穿

> 是指一个非常热点的key，在不停的扛着大并发，当这个key失效时，一瞬间大量的请求冲到持久层的数据库中，就像在一堵墙上某个点凿开了一个洞

### 缓存雪崩

> 在某一个时间段，缓存的key大量集中同时过期了，所有的请求全部冲到持久层数据库上，导致持久层数据库挂掉
> 
> 范例：双十一零点抢购，这波商品比较集中的放在缓存，设置了失效时间为1个小时，那么到了零点，这批缓存全部失效了，而大量的请求过来时，全部冲过了缓存，冲到了持久层数据库

#### Redis高可用

搭建Redis集群，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）

#### 限流降级

在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对
某个key只允许一个线程查询数据和写缓存，其他线程等待。

#### 数据预热

数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀 。 



# Cluster模式

# Sentinel模式

# 主从复制模式

## 原理

![](C:\Users\30935\AppData\Roaming\marktext\images\2023-05-23-22-15-57-image.png)

- 从数据库启动后，连接数据库，发送`SYNC`命令

- 主数据库接收到`SYNC`命令后，开始执行`BGSAVE`命令生成RDB文件，并使用缓冲区记录此后执行的所有命令

- 主数据库`BGSAVE`执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令

- 从数据库收到快照文件后，会丢弃所有旧数据，然后载入新的快照

- 张家口快照发送玩不后，开始向从数据库发送缓冲区中的写命令

- 从数据库完成快照的载入后，开始接收并执行来自主数据库缓冲区的写命令

- 主数据库每执行一个写命令，就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令

- 出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库，增量复制

- 主从刚开始连接时，先进行全量同步；全量同步完成后再进行增量同步。Redis的策略是首先会尝试增量同步，如不成功回进行全量同步



## 优点

- 读写分离

- Slave同样可以接收其他Slaves的连接和同步请求，可以为Master分压

- Master是以非阻塞的方式为Slaves提供服务，所以在同步期间，客户端仍然可以查询或修改，Slave同理

## 缺点

- 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或人工介入

- 主机宕机前若有部分数据未能同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性

- 如果多个Slave断开了，重启时最好错开，否则会同时多个SYNC请求，可能会导致Master IO剧增从而宕机

- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂
